# Инструкции к практикам и шаблон проекта

### 1. Практика "Статья"

1. Откройте репозиторий https://github.com/Mobile-Development-Course-LAB-USUE/MobileDevelopmentCourseLabApp
Этот шаблон станет общим для ваших приложений. 
2. Сделайте fork этого репозитория в свой аккаунт.
![img.png](readmeImg/img.png)
3. Склонируйте репозиторий со своей страницы в Android Studio. 
4. Проверьте, что проект собирается - приложение с тремя вкладками запускается. 
5. Переключитьесь на новую ветку, назовите ее по задаче, например `feature/article`
6. Работайте с файлами ArticleFragment.kt и fragment_article.xml
7. Сверстайте разметку вашей будущей статьи в fragment_article.xml.
Она должна включать: заголовок, подзаголовок, основную часть статьи, одно или несколько изображений, кнопки лайк-дизлайк.
Вам пригодятся: ScrollView, LinearLayout, TextView, ImageView, ImageButton. Остановимся в рамках этой задачи на них. 
8. Строки можно не выносить - мы их используем однажды и когда-то переделаем. 
9. Выставьте отступы с помощью margin и padding (https://metanit.com/java/android/3.10.php). Выставьте размеры фото и кнопок. 
Значения повторяются? Время вынести их в dimen: https://metanit.com/java/android/2.6.php
10. Стили текстов можно описывать для каждого TextView. А нужно создать стили в styles.xml и навсегда забыть о заполнении 
кучи полей: https://devcolibri.com/unit/%D1%83%D1%80%D0%BE%D0%BA-4-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%BC-styles-xml-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE-%D1%81-textappeara-2/
11. Работа с разметкой закончена. Приступаем к логике в ArticleFragment.kt. 
12. Загрузим картинку. Испортируйте библиотеку Glide (https://github.com/bumptech/glide) и загрузите изображение
по ссылке. Делается это в классе фрагмента. 
13. Оживите кнопки лайка-дизлайка: определите слушателя для кнопок (https://startandroid.ru/ru/uroki/vse-uroki-spiskom/16-urok-9-obrabotchiki-sobytij-na-primere-button.html)
и обновляйте значение счетчика.
14. Порадуйтесь результату и запечатлите его в скриншоте. Добавьте его в README.md.
15. Закоммитьте изменения и отправьте в гитхаб. Там создайте пулл-реквест (внимание - в свой мастер, а не шаблона),
а ссылку на него приложите в ведомость. Преподаватель прижет и проверит вашу работу, оставит комментарии. Как только 
препод напишет "Ок, заливай" - заливайте ваш пулл-реквест в мастер. 
16. Обновите и переключитесь на мастер. Вы готовы к следующей задаче

### 2. Практика "Список"

Эта практика позволит вам работать со списочными представлениями, что позволяет не только делать сами списки, но и гибко управлять содержимым экрана. 

1. Выберите тему, элементы которой можно представить в виде списка. Это может быть список сотрудников, книга рецептов, афиша мероприятий. В дальнейших практиках мы научимся редактировать и добавлять записи в этот список.
2. Встаньте в ветку master, там уже должна быть Практика 1, и начните новую ветку. 
3. Переименуйте все, что связано с SecondFragment, в соответствии с темой. Например ListFragment
4. Начнем с того, из чего будет будет состоять список. Создайте разметку одного элемента в папке layout
5. В разметке бывшего SecondFragment создайте единственный виджет - RecyclerView. Не забудьте установить LayoutManager
6. Создайте класс - модель ваших данных, например Рецепт, Сотрудник и т.д.
7. Создайте источник данных, возвращающий список моделей из п. 6.
8. Создайте адаптер (Adapter), который будет отображать ваши данные из п.7 на элементах из п.4. Для этого:
9. Создайте ViewHolder - класс, который запомнит все, что нужно для обращения к элементу разметки, который и дается ему на вход. Достаточно привязять itemView к binding, и предоставлять последний.
10. Создайте в адаптере коллекцию, в которой будут храниться элементы.
11. Переопределите метод onCreateViewHolder так, чтобы он принимал элемент разметки и возвращал созданный в п.9 ViewHolder.
12. Теперь, если мы переопределим метод onBindViewHolder, мы можем взять элемент из коллекции (10) и холдер (9), и заполнить вьюшку из холдера данными из элемента коллекции. Здесь же можно навесить обработчики событий.
13. Сделайте в адаптере метод, который принимает коллекцию и говорит адаптеру обновиться с этими новыми данными (notifyDatasetChanged). Так мы и поставим данные в RecyclerView.
14. Создайте во Fragment экземпляр адаптера. Назначьте его RecyclerView и воспользуйтесь методом установки данных (13) с данными из источника (7). Теперь, когда мы запустим приложение, на втором фрагменте появится список!
15. Попробуйте сделать список интерактивным. Например, при нажатии на элемент будут показаны скрытые подробности. Изменить один элемент поможет notifyItemChanged
16. Повторите пп. 14-16 из прошлой практики

### 3. Практика "Карточка"

В рамках этой практики вам предстоит подробнее познакомиться с навигацией и гибкими разметками при помощи ConstraintLayout, а также с некоторыми применениями Intent. 

1. Для выполнения этой практики вам будут необходимы результаты Практики 2 "Список". Выполните сначала ее. 
2. После вливания "Списка" встаньте в мастер и стартуйте новую ветку.
3. Подумайте, какую более полную информацию можно показывать по элементам вашего списка. Например, для списка рецептов это будет сам рецепт, для списка сотрудников - карточка сотрудника, для расписания занятий - информация о занятии. Именно переход на этот экран мы и будем делать.
4. Создайте пару фрагмент + разметка, которые будут отвечать за ваш экран.
5. В графе навигации (mobile_navigation.xml) создайте новый destination. Для фрагмента списка добавьте новый action, который позволяет сделать переход на этот новый экран.
6. Вместо раскрытия элемента сделайте новый обработчик нажатия клика на элемент списка. Теперь должен происходить переход по action из прошлого пункта. https://developer.android.com/guide/navigation/use-graph/navigate#id 
7. Чтобы передать в "Карточку" данные из элемента списка, при переходе добавьте данные в Bundle и приложите его (или с помощью аргументов навигации). Чтобы можно было передать модель данных целиком, сделайте ее Serializable. https://developer.android.com/guide/navigation/use-graph/pass-data#bundle
8. Чтобы достать данные в "Карточке", воспользуйтесь свойством фрагмента arguments. Теперь у вас есть данные, которыми вы заполните верстку. 
9. Сверстайте вашу "Карточку" в файле разметки. Используйте ConstraintLayout и его возможности: относительное позиционирование (startTo_start, topTo и тд), выравнивание и оступы, барьеры (barrier), цепочки (chain), смещения (bias) и т.д. То, что вам понадобится, зависит от вашей фантазии, но постарайтесь использовать большую часть из списка возможностей. 
10. Позаботьтесь о том, чтобы на вашем экране работала и системная кнопка "Назад", и стрелка в тулбаре. Кроме этого, на этом экране не нужен навбар с тремя основынми экранами. Это можно настроить в контейнере наших фрагментов - MainActivity.
11. Сделаем возможность поделиться информацией из "Карточки". Добавим на тулбар иконку "Поделиться". Делается это при помощи меню.
12. Создайте в ресурсах menu новый menu-файл и опишите там пункт меню. Поставьте ему иконку (share есть в стандартном наборе)
13. В onCreateOptionsMenu фрагмента назначьте созданное в прошлом меню, а в onOptionsItemSelected опишите реакцию на нажатие. 
14. Этой реакцией станет запуск Intent для отправки данных. Он запустит стандартный экран шеринга https://developer.android.com/training/sharing/send
15. Повторите пп. 14-16 из первой практики

### 4. Практика "Комментарий"

В рамках этой практики вам предстоит попробовать паттерн Model View Presenter и библиотеку Moxy, а также внедрение зависимостей и Dagger. Пробовать мы это будем на примере поля ввода. 

1. Для выполнения этой практики вам будут необходимы результаты Практики 3 "Карточка" (может не целиком, главное сам экран). Выполните сначала ее. После вливания "Карточки" встаньте в мастер и стартуйте новую ветку.
2. Возьмите экран из практики "Карточка" и сверстайте на нем простую форму ввода: по нажатию на раздел "Комментарии" будет открывтаться блок с полеем ввода, кнопкой "Отправить" и списком комментариев. 
3. Для поля ввода используйте EditText. Дополнительно - оберните его TextInputLayout для дополнительных возможностей. Экспериментируйте: например, ограничьте количество символов, которые можно ввести. 
4. Сделайте так, чтобы при пустом поле кнопка "Отправить" была недоступна ИЛИ при пустом поле и нажатии кнопки показывалась ошибка. (у EditText/TextInputLayout есть свойство error)
5. Расположите под полем ввода список комментариев, которые будут добавляться по нажатию на кнпоку.  
6. Много логики получается во фрагменте, а состояние не сохраняется. Время применить паттерн MVP. Добавьте библиотеку Moxy:
   
```
def moxyVersion = "2.2.2"
implementation "com.github.moxy-community:moxy:$moxyVersion"
kapt "com.github.moxy-community:moxy-compiler:$moxyVersion"
implementation "com.github.moxy-community:moxy-androidx:$moxyVersion"
implementation "com.github.moxy-community:moxy-ktx:$moxyVersion"
```

Не забудьте добавить плагин kapt и сделайте sync. 
6. Создайте класс CardPresenter (наследник MvpPresenter), интерфейс CardView (Наследник MvpView), а CardFragment сделайте наследником MvpAppCompatFragment и CardMvpView. Так эти компоненты смогут работать в связке. 

7. В CardView вынесите функции вашего экрана, которые будет вызывать презентер и выполянть фрагмент. Это любые действия, меняющие состояние экрана, например показать скрытые виджеты, сделать доступной кнопку, очистить поле ввода.
   
9. В презентере создайте функции, которые вызываются при событии с экрана и требуется принятие решения. Например, юзер нажал на поле "Комментарий", значит, если комменатрии не показаны, их нужно показать, и скрыть, если уже показаны. Показ и скрытие - вызов функции из прошлого пункта.
    
11. Перепишите CardFragment так, чтобы о событиях он докладывал презентеру. Реализуйте все функции из CardView - то, что будет вызываться из презентера.
    
13. В CardView не забудьте указать стратегию Moxy, согласно которой она повторит команды.
    
15. Следующая задача - предоставить фрагменту презентер. Нужно это сделать так, чтобы для воскресшей вьюшки брался тот же презентер, что был изначально. Для этого надо создать "хранилище" зависимостей и управлять им. В этом поможет Dagger. Добавьте нужныые зависимости: 

```
def daggerVersion = "2.50"
    implementation "com.google.dagger:dagger:$daggerVersion"
    kapt "com.google.dagger:dagger-compiler:$daggerVersion"
```

12. Создайте класс App, наследник Application. Он переживет ЖЦ активити. Там будет создан AppComponent - компонент Dagger, управляющий зависимостями.
    
14. В AppComponent поместите следующее:
    
```
@Component
@Singleton
interface AppComponent {

    //Fragments
    fun inject(fragment: CardFragment)

    @Component.Factory
    interface Factory {
        fun create(@BindsInstance context: Context): AppComponent
    }
}
```

14. Чтобы получить презентер в CardFragment, нужно:
    
```
    @Inject
    lateinit var presenterProvider: Provider<CardPresenter>

    private val presenter by moxyPresenter { presenterProvider.get() }

    override fun onCreate(savedInstanceState: Bundle?) {
        App.appComponent?.inject(this)
        super.onCreate(savedInstanceState)
    }
```

Не забудьте пометить конструктор CardPresenter аннотацией Inject. Теперь вы можете пользоваться presenter в вашем фрагменте - его будет создавать компонент. 

15. Проверьте, что, например, при перевороте экрана состояние вашего экрана сохраняется.
    
17. Перепишите в стиле MVP "Статью" и "Список"
  
19. Повторите пп. 14-16 из первой практики

P.S. за подсказками в https://github.com/dekabrsky/MobileDevelopmentCourseLabApp/tree/feature/comment 

